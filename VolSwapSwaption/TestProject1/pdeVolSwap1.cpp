/* Generated by 
     RKS

   
(* pdeVolSwap1.s *)

PDE;  CrankNicolson;
Region[xMin<=x1<=xMax && xMin<=x2<=xMax && 0<=y<=1
       && 0<=tau<=TMax, GeneralCoordinates[{x1,x2,y},tau]];
       OldCoordinates[{{S,Sp,A},t}];
       S ==Spot Exp[x1];          Sp==Spot Exp[x2];
       A==AMin + (AMax-AMin) y;   t==tau;
When[Interior, BlackScholes1D[]];
When[Boundary, AutomaticBC; OneSidedDifference[1]];
When[min[x1]||max[x1], der[V,S]==0];
When[max[tau], V==Vol - K];
Vol==Sqrt[Max[0, (A - (Log[S/S0]/nsampTot)^2)/dTAve]];
dTAve==(TContract/nsampTot);

DiscreteEvents[
     Path[direction[Sp],
          function[Sp==SumOf[S-Sp]],
          tsample==RDates, nsample==nsampToGo,
          InterpolateLinear],
     Path[direction[A],
          function[
              A==SumOf[(Log[S/Sp]^2-A)/(isamp + nsampSoFar)]],
          tsample==RDates, nsample==nsampToGo,
          CubicSpline]];
ReadArray[RDates, {isamp,1,nsampToGo}, "RDates.dat"];

Default[TaggedInputFile["volswap.dat"], Labelled];
Output[V, "VofA.out",   CubicSpline, S==Spot && Sp==SpSpot];
Output[V, "atSpot.out", CubicSpline, S==Spot && Sp==SpSpot && A==ASpot];

ReadOrCompute[{xMin,xMax,AMin,AMax}];
    stddevs==Max[4 sigma Sqrt[TMax], 0.1];
    xMin==-stddevs - r TMax;
    xMax== stddevs + D0 TMax;
    AMin==0.25 sigma^2 dTAve;
    AMax==4 sigma^2 dTAve;
ReadOrCompute[{iMax,kMax,nMax}];
    delx==Min[xMax-xMin,4]/100;
    iMax0==Round[(xMax-xMin)/delx];
    kMax0==20;
    ndiff==Round[(sigma/delx)^2 TMax /10];
    nconv==Round[2 Abs[r-D0]/delx TMax];
    nMax0==Max[20, Max[ndiff, nconv]];
    iMax==Round[iMax0 Sqrt[Accuracy]];
    nMax==Round[nMax0 Sqrt[Accuracy]];
    kMax==Round[kMax0 Sqrt[Accuracy]];
    nsampTot==nsampSoFar+nsampToGo;
    TMax==RDates[nsampToGo];
MInteger[{nsampSoFar,nsampTot}];
GridSize[{{iMax,iMax,kMax},nMax}];


  Macros expanded by specification were: 
    RKS/PDE.s
(* :HelpText: PDE[] is a specification macro that invokes a
    collection of specifications frequently used in generating 
    option pricing models in C.*)
(* :HelpLongText: We set the default memory allocation method 
    to DynamicAllocation, the default solver to TriDiagonal, 
    and the default time evolution algorithm to EvolveFixed.
    We specify that time should run backwards, that Microsoft
    C is the target language, and that double precision is to
    be used for all real numbers.  We suppress tensor order
    and physical units checking to reduce synthesis time. *)
(* :FileName: PDE.s *)

BeginAtFinalTime;
NoTensorOrderChecks;
NoUnitChecks;
Default[EvolveFixed, DynamicAllocation, msC];
AllDouble;

    RKS/BlackScholes1D.eqn
(* :FileName: BlackScholes1D.eqn *)
(* :HelpText: Equation Generator for the 1D Black-Scholes  Equation with greeks *)
(* :HelpLongText:  The equation generator for the 1D Black-Scholes Equation for option valuation, and optionally, equations for the greeks Vega and Rho.  (Delta, Gamma, and Theta can be derived by differentiation of value V.)  See Paul Wilmott, Jeff Dewynne, Sam Howison,  "Option Pricing"   Oxford Financial Press, 1993. *)

(*
   der[V,t] + (1/2)sigma^2 S^2 der[V,{S,2}] +
                            (r-D0) S der[V,S] - r V == 0

   in price (S) coordinates and backward time (t).  

   Defines the variables:
   Variable[V,     Scalar, Dollars,      "option value"];
   Variable[sigma, Scalar, Time^(-1/2),  "volatility"];
   Variable[r,     Scalar, Time^(-1),    "interest rate"];
   Variable[D0,    Scalar, Time^(-1),    
                   "continuous dividend yield"]; *)

(* :HelpSyntax: BlackScholes1D[] | BlackScholes1D[Keywords->{<subset of {Vega,Rho}>}, <var>->value] *)
(* :HelpExamples:
    BlackScholes1D[Keywords->{Vega,Rho}]
    BlackScholes1D[D0->0]
    BlackScholes1D[Keywords->{Vega,Rho}, D0->0] *)

PhysicalMeaning[S,Dollars];

(* Create the Dependent Variables *)
   Variable[V,     Scalar, Dollars,      "option value"];
   Variable[sigma, Scalar, Time^(-1/2),  "volatility"];
   Variable[r,     Scalar, Time^(-1),    "interest rate"];
   Variable[D0,    Scalar, Time^(-1),    
                   "continuous dividend yield"];

(* Create and name Black-Scholes Equation for option value V *)
   Equation[der[V,t] + (1/2)sigma^2 S^2 der[V,{S,2}] +
                               (r-D0) S der[V,S] - r V == 0,
     BuildSymbol[V,"Eqn"]];

 (* Create and name the equation for Vega=der[V,sigma] *)
   IsAKeyWord[Vega,
       Variable[Vega, Scalar, Dollars Time^(1/2), "Vega"];
       Equation[Greek[BuildSymbol[V, "Eqn"],{Vega,der[V,sigma]}],
       BuildSymbol[Vega,"Eqn"]];
       (* Create and name the equation for Volga=der[Vega,sigma] *)
       IsAKeyWord[Volga,
           Variable[Volga, Scalar, Dollars Time^(1/2), "Volga"];
           Equation[Greek[BuildSymbol[Vega, "Eqn"],{Volga,der[Vega,sigma]}],
           BuildSymbol[Volga,"Eqn"]]
   ]];

 (* Create and name the equation for Volga=der[Vega,sigma]
   IsAKeyWord[Volga,
       Variable[Volga, Scalar, Dollars Time^(1/2), "Volga"];
       Equation[Greek[BuildSymbol[Vega, "Eqn"],{Volga,der[Vega,sigma]}],
       BuildSymbol[Volga,"Eqn"]]
   ]; *)

(* Create and name the equation for Rho=der[V,r] *)
   IsAKeyWord[Rho,
       Variable[Rho, Scalar, Dollars Time, "Rho"];
       Equation[Greek[BuildSymbol[V, "Eqn"],{Rho,der[V,r]}],
       BuildSymbol[Rho,"Eqn"]]
   ];

(* Create and name the equation for RhoD=der[V,D0] *)
   IsAKeyWord[RhoD,
       Variable[RhoD, Scalar, Dollars Time, "RhoD"];
       Equation[Greek[BuildSymbol[V, "Eqn"],{RhoD,der[V,D0]}],
        BuildSymbol[RhoD,"Eqn"]]
   ];

 */

/**************  ARRAY FORMAT INSTRUCTIONS **************

Please use the following information to check carefully the formats
  of your arrays.  Although all arrays are dimensioned from 0,
  ReadArray arrays are filled from 0 unless specified otherwise.
  ReadFile arrays are filled from 1; ReadTable arrays, from 0.
  ReadTable files contain a maximum *index* (not number of items) count.

If you modify the code to input arrays directly, please check
  that the initializations fill from 0 or 1 as appropriate.

                          ****

   The table for RDates in file "RDates.dat" has maximum index
      nsampToGo, 
     with minimum index 1.
      The index bounds are not read from this file.
        Following should be the nsampToGo elements,
      to be stored in RDates(1..nsampToGo).


******************* END FORMAT INSTRUCTIONS *******************/


#include "FACommonLib.h"
#include "FAArrayN.h"
#include <float.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "FAInterpLib.h"
#include "TaggedInput.h"

#define HaltingInKrylov 1
#define CGSolverOld 2
#define CGSolverAlpha 3
#define QMRSolverRho 4
#define QMRSolverXi 5
#define QMRSolverEpsi 6
#define QMRSolverDelta 7
#define QMRSolverGamma1 8
#define QMRSolverGamma2 9
#define BiCGSolverRho 10
#define BiCGSolverPtqq 11
#define CGSSolverRho 12
#define CGSSolverRtvh 13
#define PBCGSTSolverRho 14
#define PBCGSTSolverRtvv 15
#define PBCGSTSolverOmega 16
#define BinaryLoopSmallArrays 17
#define StabilityFailure 18
#define ErrorAbort 19
#define AllocationError 20
#define ToleranceTooSmall 21
#define MaxitExceeded 22
#define FileOpenError 23
#define FileNotFound 24
#define fscanfError 25
#define TaggedInputError 26
#define PinnedGridSamePointError 27
#define BisectionError 28
#define BisectionBracketError 29
#define InterpolationDeltaError 30
#define MissingUserTypeInitCode 31
#define MissingStubFunctionBody 32
#define UnsortedSampleArray 33
#define SawToothOnePointError 34
#define SawToothNoZeroError 35
#define BrentConvergenceFailure 39
#define MCFAOldSobolOverflow 40
#define MCFASobolOverflow2 38
#define FANormalFlag 0
#define MaxErrorLength 128
#define MaxMessages 10
/* Define macro to check errors on opening file for writing */
#undef openfilepdeVolSwap1MW
#define openfilepdeVolSwap1MW(stream, file) \
   (stream) = fopen((file), "w");\
   if ((stream) == NULL)\
       {\
	throw new FAFileException(FileOpenError, "%s%s%s",\
	"Cannot open file ", (file), " for writing.");\
       }

/* Define macro to check errors on opening file for reading */
#undef openfilepdeVolSwap1MR
#define openfilepdeVolSwap1MR(stream, file) \
   (stream) = fopen((file), "r");\
   if ((stream) == NULL)\
       {\
	throw new FAFileException(FileOpenError, "%s%s%s",\
	"Cannot open file ", (file), " for reading.");\
       }

/* Define macro to check errors on reading input line */
#undef fscanf$pdeVolSwap1M
#define fscanf$pdeVolSwap1M(file, format, numvars, vars) \
   if (fscanf((file), (format), spreadargs##numvars vars) != (numvars))\
       {\
        throw new FAErrorException(fscanfError, \
            "%s%s%s%s\n","Input error while reading ", #vars,\
              " from ", #file);\
       }


#undef spreadargs1
#define spreadargs1(a1) a1


static void ComputeIndStencils1(
    double D0,
    double dx1,
    int iMax,
    const FAArray1Ref<double>& J11,
    int kMax,
    double r,
    const FAArray1Ref<double>& S,
    FAArray2Ref<double>& SA0,
    FAArray2Ref<double>& SB0,
    double sigma
    );
static void ComputeStencils1(
    double dtau,
    double dtaum1,
    double dx1,
    int iMax,
    const FAArray1Ref<double>& J11,
    int kMax,
    FAArray2Ref<double>& SA,
    const FAArray2Ref<double>& SA0,
    FAArray2Ref<double>& SB,
    const FAArray2Ref<double>& SB0
    );
static void CreateGrids1(
    FAArray1Ref<double>& A,
    double AMax,
    double AMin,
    double dx1,
    double dx2,
    double dy,
    int iMax,
    int kMax,
    FAArray1Ref<double>& S,
    FAArray1Ref<double>& Sp,
    double Spot,
    double xMin
    );
static int CRound(
    double delx
    );
static int pdeVolSwap1fn(
    double Accuracy,
    double AMax,
    double AMin,
    double ASpot,
    FAArray1Ref<double>* & Ax,
    double D0,
    int *iMaxx,
    double K,
    int *kMaxx,
    int nMax,
    int nsampSoFar,
    int nsampToGo,
    double r,
    FAArray1Ref<double>& RDates,
    double S0,
    double sigma,
    double Spot,
    double SpSpot,
    FAArray1Ref<double>* & Spx,
    FAArray1Ref<double>* & Sx,
    double TContract,
    double xMax,
    double xMin,
    double *VOut1x,
    FAArray1Ref<double>* & VOutx,
    int kMax,
    int iMax
    );
static int pdeVolSwap1fnC(
    double Accuracy,
    double AMax,
    double AMin,
    double ASpot,
    double **AxC,
    double D0,
    int *iMaxx,
    double K,
    int *kMaxx,
    int nMax,
    int nsampSoFar,
    int nsampToGo,
    double r,
    double *RDatesC,
    double S0,
    double sigma,
    double Spot,
    double SpSpot,
    double **SpxC,
    double **SxC,
    double TContract,
    double xMax,
    double xMin,
    double *VOut1x,
    double **VOutxC,
    int kMax,
    int iMax
    );
static void SetDateIndices1(
    const FAArray1Ref<double>& RDates,
    FAArray1Ref<double>& RDates1,
    int nsampToGo,
    int *isampminp,
    int *nsampToGo1p,
    double TMax,
    double ttest,
    int arraymin
    );
static void TriDiag(
    const FAArray3Ref<double>& g,
    const FAArray2Ref<double>& SA,
    FAArray3Ref<double>& V,
    int iMax,
    int kMax,
    FAArray1Ref<double>& TriTa,
    FAArray1Ref<double>& TriTb
    );
static void ValidateArraySorted1(
    const FAArray1Ref<double>& RDates,
    int nsampToGo
    );
static void VectorMatrixMultiply4(
    const FAArray2Ref<double>& SB,
    const FAArray3Ref<double>& V,
    FAArray3Ref<double>& g,
    int iMax,
    int kMax
    );

int main()
{
    int iMax,iMaxx,itvar1,k1,kMax,kMaxx,nMax,nsampSoFar,nsampToGo;
    double *AC,Accuracy,AMax,AMin,ASpot,D0,K,r,S0,*SC,sigma,*SpC,Spot,
       SpSpot,TContract,VOut1x,*VOutC,xMax,xMin;
    FILE *IOUNIT,*IOUNIT1,*IOUNIT2,*IOUNIT3;
    ArgumentRecord volswapInputTable[19];
    
    /* *** Key to program variables: *** */
    /* Accuracy, AMax, AMin, ASpot, K, nsampSoFar, RDates, S0, Spot,    
       SpSpot, TContract, VOut1x: solution variable */
    /* D0: continuous dividend yield */
    /* iMax, iMaxx: number of grid cells for x2 */
    /* IOUNIT, IOUNIT1, IOUNIT2, IOUNIT3: I/O channel */
    /* k1: index variable for y */
    /* kMax, kMaxx: number of grid cells for y */
    /* nMax: number of grid cells for tau */
    /* nsampToGo: array maximum for RDates */
    /* r: interest rate */
    /* sigma: volatility */
    /* VOut: interpolated value of VOut (option value)  */
    /* xMax: maximum physical value in dimension x2 */
    /* xMin: minimum physical value in dimension x2 */
    try {
    /* Read Tagged Input File */
    openfilepdeVolSwap1MR(IOUNIT2,"volswap.dat");
    setupargs(volswapInputTable, 0, 
       "Accuracy", Accuracy, READINPUTSDOUBLE);
    setupargs(volswapInputTable, 1, "AMax", AMax, READINPUTSDOUBLE);
    setupargs(volswapInputTable, 2, "AMin", AMin, READINPUTSDOUBLE);
    setupargs(volswapInputTable, 3, "ASpot", ASpot, READINPUTSDOUBLE);
    setupargs(volswapInputTable, 4, "D0", D0, READINPUTSDOUBLE);
    setupargs(volswapInputTable, 5, "iMax", iMax, READINPUTSINTEGER);
    setupargs(volswapInputTable, 6, "K", K, READINPUTSDOUBLE);
    setupargs(volswapInputTable, 7, "kMax", kMax, READINPUTSINTEGER);
    setupargs(volswapInputTable, 8, "nMax", nMax, READINPUTSINTEGER);
    setupargs(volswapInputTable, 9, 
       "nsampSoFar", nsampSoFar, READINPUTSINTEGER);
    setupargs(volswapInputTable, 10, 
       "nsampToGo", nsampToGo, READINPUTSINTEGER);
    setupargs(volswapInputTable, 11, "r", r, READINPUTSDOUBLE);
    setupargs(volswapInputTable, 12, "S0", S0, READINPUTSDOUBLE);
    setupargs(volswapInputTable, 13, "sigma", sigma, READINPUTSDOUBLE);
    setupargs(volswapInputTable, 14, "Spot", Spot, READINPUTSDOUBLE);
    setupargs(volswapInputTable, 15, 
       "SpSpot", SpSpot, READINPUTSDOUBLE);
    setupargs(volswapInputTable, 16, 
       "TContract", TContract, READINPUTSDOUBLE);
    setupargs(volswapInputTable, 17, "xMax", xMax, READINPUTSDOUBLE);
    setupargs(volswapInputTable, 18, "xMin", xMin, READINPUTSDOUBLE);
    if (ReadInputs(IOUNIT2,volswapInputTable,19)!=0)
        {
        fclose(IOUNIT2);
        throw new FAErrorException(		
           "ReadInput failed",TaggedInputError);
        }
    fclose(IOUNIT2);
    /* Read RDates from file */
    FAArray1<double>RDates(nsampToGo + 1);
    if (nsampToGo>=1)
        {
        openfilepdeVolSwap1MR(IOUNIT3,"RDates.dat");
        for (itvar1=1; itvar1<=nsampToGo; itvar1++) {
            fscanf$pdeVolSwap1M(IOUNIT3,"%lg",1,((&RDates(itvar1))));
        }
        fclose(IOUNIT3);
        }
    ValidateArraySorted1(RDates,nsampToGo);
    /*                            */
    /* Call the computation function. */
    pdeVolSwap1fnC(Accuracy,AMax,AMin,ASpot,&AC,D0,&iMaxx,K,&kMaxx,nMax,
       nsampSoFar,nsampToGo,r,RDates.array(),S0,sigma,Spot,SpSpot,&SpC,
       &SC,TContract,xMax,xMin,&VOut1x,&VOutC,kMax,iMax);
    FAArray1Ref<double> S(SC, iMaxx + 1);
    FAArray1Ref<double> Sp(SpC, iMaxx + 1);
    FAArray1Ref<double> A(AC, kMaxx + 1);
    FAArray1Ref<double> VOut(VOutC, kMaxx + 1);
    /*                            */
    /* Writing collected output to file VofA.out from ResultEqc. */
    openfilepdeVolSwap1MW(IOUNIT,"VofA.out");
    for (k1=0; k1<=kMaxx; k1++) {
        fprintf(IOUNIT, 
           " %g %18.8e %18.8e %18.8e %18.8e\n"
           , 0.,Spot,SpSpot,A(k1),VOut(k1));
    }
    fprintf(IOUNIT, "\n");
    fclose(IOUNIT);
    /* Writing collected output to file atSpot.out from ResultEq1c. */
    openfilepdeVolSwap1MW(IOUNIT1,"atSpot.out");
    fprintf(IOUNIT1, 
       " %g %18.8e %18.8e %18.8e %18.8e\n"
       , 0.,Spot,SpSpot,ASpot,VOut1x);
    fprintf(IOUNIT1, "\n");
    fclose(IOUNIT1);
    delete[] AC;
    delete[] SC;
    delete[] SpC;
    delete[] VOutC;
    return 0;
    /* end try */
    }
    catch(FAErrorException* ex1)
	{
	// Handle exceptions thrown by SF core code
	printf
       (
       "%s\n"
       , ex1->getMessage());
	int rc = ex1->getErrorType();
	delete ex1;
       
	return rc;
	}
    catch(FAException* ex2)
	{
	// Handle any exceptions thrown by call-backs
	printf
       ("%s\n", ex2->getMessage());
	delete ex2;
	return -1;
	}
    return 0;
}

static int pdeVolSwap1fnC(
    double Accuracy,
    double AMax,
    double AMin,
    double ASpot,
    double **AxC,
    double D0,
    int *iMaxx,
    double K,
    int *kMaxx,
    int nMax,
    int nsampSoFar,
    int nsampToGo,
    double r,
    double *RDatesC,
    double S0,
    double sigma,
    double Spot,
    double SpSpot,
    double **SpxC,
    double **SxC,
    double TContract,
    double xMax,
    double xMin,
    double *VOut1x,
    double **VOutxC,
    int kMax,
    int iMax
    )
{
    
    /* *** Key to program variables: *** */
    /* A, Accuracy, AMax, AMin, ASpot, Ax, K, nsampSoFar, RDates, S0,   
       Sp, Spot, SpSpot, Spx, Sx, TContract, VOut1x, VOutx: solution    
       variable */
    /* D0: continuous dividend yield */
    /* iMax, iMaxx: number of grid cells for x2 */
    /* kMax, kMaxx: number of grid cells for y */
    /* nMax: number of grid cells for tau */
    /* nsampToGo: array maximum for RDates */
    /* r: interest rate */
    /* sigma: volatility */
    /* xMax: maximum physical value in dimension x2 */
    /* xMin: minimum physical value in dimension x2 */
    FAArray1Ref<double> *Ax;
    FAArray1Ref<double> RDates(RDatesC, nsampToGo + 1);
    FAArray1Ref<double> *Spx;
    FAArray1Ref<double> *Sx;
    FAArray1Ref<double> *VOutx;
    /* Call FAArray C++ Spreadsheet function  */
    pdeVolSwap1fn(Accuracy,AMax,AMin,ASpot,Ax,D0,iMaxx,K,kMaxx,nMax,
       nsampSoFar,nsampToGo,r,RDates,S0,sigma,Spot,SpSpot,Spx,Sx,
       TContract,xMax,xMin,VOut1x,VOutx,kMax,iMax);
    *AxC = Ax->array();
    delete Ax;
    *SpxC = Spx->array();
    delete Spx;
    *SxC = Sx->array();
    delete Sx;
    *VOutxC = VOutx->array();
    delete VOutx;
    return 1;
}

static int pdeVolSwap1fn(
    double Accuracy,
    double AMax,
    double AMin,
    double ASpot,
    FAArray1Ref<double>* & Ax,
    double D0,
    int *iMaxx,
    double K,
    int *kMaxx,
    int nMax,
    int nsampSoFar,
    int nsampToGo,
    double r,
    FAArray1Ref<double>& RDates,
    double S0,
    double sigma,
    double Spot,
    double SpSpot,
    FAArray1Ref<double>* & Spx,
    FAArray1Ref<double>* & Sx,
    double TContract,
    double xMax,
    double xMin,
    double *VOut1x,
    FAArray1Ref<double>* & VOutx,
    int kMax,
    int iMax
    )
{
    int i,iMax0,isamp2,isampmin,j,k1,n,nconv,ndiff,nsampToGo1,nsampTot;
    double delx,dtau,dtaum1,dTAve,dx1,dx2,dy,eps,kMax0,nMax0,savedt,
       stddevs,tau,temp10,temp11,temp12,temp13,temp14,temp18,tend,TMax,
       ttest,VOut1;
    
    /* *** Key to program variables: *** */
    /* A, Accuracy, AMax, AMin, ASpot, Ax, delx, dTAve, iMax0, J11, K,  
       kMax0, nconv, ndiff, nMax0, nsampSoFar, nsampTot, RDates, S, S0, 
       slicetmp1, slicetmp2, Sp, Spot, SpSpot, Spx, stddevs, Sx,        
       TContract, Vol, VOut1x, VOutx, zz1, zz2: solution variable */
    /* D0: continuous dividend yield */
    /* dtau: step size for tau */
    /* dtaum1: value for dtau 1 time steps ago */
    /* dx1: step size for x1 */
    /* dx2: step size for x2 */
    /* dy: step size for y */
    /* eps: machine epsilon */
    /* fpp1, fpp2, fpp3, fpp6, fpptmp1: second derivative temporary     
       array */
    /* g: right hand side of the linear system; the y in Ax=y. */
    /* i: index variable for x1 */
    /* iMax, iMaxx: number of grid cells for x2 */
    /* isamp2: Index for Path array */
    /* isampmin: Minimum of Path array */
    /* j: index variable for x2 */
    /* k1: index variable for y */
    /* kMax, kMaxx: number of grid cells for y */
    /* n: index variable for tau */
    /* nMax: number of grid cells for tau */
    /* nsampToGo: array maximum for RDates */
    /* nsampToGo1: Maximum of Path array */
    /* r: interest rate */
    /* RDates1: Auxiliary array for Path sample array */
    /* SA: stencil array of the system; the A in Ax=y. */
    /* SA0: part of SA that is proportional to dt. */
    /* savedt: saved value of dt */
    /* SB: coefficients for right hand side of the linear system */
    /* SB0: part of SB that is proportional to dt */
    /* sigma: volatility */
    /* tau: time variable */
    /* temp10, temp11, temp12, temp13, temp14, temp18: common           
       subexpression temporary */
    /* tend: time to save results */
    /* TMax: minimum physical value in dimension tau */
    /* TriT1i1, TriT1j1, TriT1k11, TriT2i1, TriT2j1, TriT2k11: spline   
       temporary array */
    /* TriTa, TriTb: temporary, same size as diagonal */
    /* ttest: minimal size test */
    /* V: option value */
    /* VOut: interpolated value of VOut (option value)  */
    /* VOut1: interpolated value of VOut1 (option value)  */
    /* xMax: maximum physical value in dimension x2 */
    /* xMin: minimum physical value in dimension x2 */
    /* xnew, xnew1: updated var */
    /* yi1, yi2: adjusted for discrete events */
    /* Compute machine epsilon. */
    eps = 1.;
    while (1.!=eps + 1.) {
        eps = eps*0.5;
    }
    eps = eps*2.;
    kMax0 = 20.;
    /* Initialize geometric parameter */
    if (kMax==-999)
        {
        kMax = CRound(sqrt(Accuracy)*kMax0);
        }
    TMax = RDates(nsampToGo);
    /* Compute the value for nsampTot; formula is nsampTot == nsampSoFar
       + nsampToGo; discretization methods are Implicit[1/2] and        
       CentralSpaceDifference[2]; truncation error is 0; Eq19c. */
    nsampTot = nsampSoFar + nsampToGo;
    /* Compute the value for dTAve; formula is dTAve ==                 
       TContract/nsampTot; discretization methods are Implicit[1/2] and 
       CentralSpaceDifference[2]; truncation error is 0; Eq4c. */
    dTAve = TContract / (double)(nsampTot);
    VOutx = new FAArray1<double>(kMax + 1);
    FAArray1Ref<double> VOut(*VOutx);
    FAArray1<double>xnew1(kMax + 1);
    FAArray1<double>yi2(kMax + 1);
    Ax = new FAArray1<double>(kMax + 1);
    FAArray1Ref<double> A(*Ax);
    /* Initialize step size */
    dy = 1. / (double)(kMax);
    FAArray1<double>fpp6(kMax + 1);
    FAArray1<double>TriT1k11(kMax + 1);
    FAArray1<double>TriT2k11(kMax + 1);
    dtaum1 = TMax;
    /* Compute the value for stddevs; formula is stddevs == Max[0.1,    
       4*sigma*Sqrt[TMax]]; discretization methods are Implicit[1/2] and
       CentralSpaceDifference[2]; truncation error is 0; Eq5c. */
    stddevs = max(4*sigma*sqrt(TMax),0.1);
    ttest = max(fabs(TMax),0.)*max(eps*100.,1.e-12);
    FAArray1<double>RDates1(nsampToGo + 1);
    ValidateArraySorted1(RDates,nsampToGo);
    SetDateIndices1(RDates,RDates1,nsampToGo,&isampmin,&nsampToGo1,TMax,
       ttest,1);
    /* Compute the value for AMax; formula is AMax == 4*dTAve*sigma^2;  
       discretization methods are Implicit[1/2] and                     
       CentralSpaceDifference[2]; truncation error is 0; Eq9c. */
    if (AMax==-999.)
        {
        AMax = 4*dTAve*sigma*sigma;
        }
    /* Compute the value for AMin; formula is AMin ==                   
       0.25*dTAve*sigma^2; discretization methods are Implicit[1/2] and 
       CentralSpaceDifference[2]; truncation error is 0; Eq8c. */
    if (AMin==-999.)
        {
        AMin = dTAve*sigma*sigma*0.25;
        }
    /* Initialize geometric parameter */
    if (xMax==-999.)
        {
        xMax = stddevs + D0*TMax;
        }
    if (xMin==-999.)
        {
        xMin = -stddevs - r*TMax;
        }
    /* Compute the value for delx; formula is delx == Min[4, xMax -     
       xMin]/100; discretization methods are Implicit[1/2] and          
       CentralSpaceDifference[2]; truncation error is 0; Eq10c. */
    delx = min(xMax - xMin,4.) / 100.;
    /* Compute the value for iMax0; formula is iMax0 == CRound[(xMax -  
       xMin)/delx]; discretization methods are Implicit[1/2] and        
       CentralSpaceDifference[2]; truncation error is 0; Eq11c. */
    iMax0 = CRound((xMax - xMin) / delx);
    /* Initialize geometric parameter */
    if (iMax==-999)
        {
        iMax = CRound(sqrt(Accuracy)*iMax0);
        }
    temp18 = (xMax - xMin) / (double)(iMax);
    /* Compute the value for nconv; formula is nconv ==                 
       CRound[(2*TMax*Abs[D0 - r])/delx]; discretization methods are    
       Implicit[1/2] and CentralSpaceDifference[2]; truncation error is 
       0; Eq14c. */
    nconv = CRound((2*TMax*fabs(D0 - r)) / delx);
    /* Compute the value for ndiff; formula is ndiff ==                 
       CRound[(sigma^2*TMax)/(10*delx^2)]; discretization methods are   
       Implicit[1/2] and CentralSpaceDifference[2]; truncation error is 
       0; Eq13c. */
    ndiff = CRound((sigma*sigma*TMax) / (10.*delx*delx));
    FAArray3<double>g(iMax + 1, iMax + 1, kMax + 1);
    FAArray2<double>SA(iMax + 1, 3);
    FAArray2<double>SA0(iMax + 1, 3);
    FAArray2<double>SB(iMax + 1, 3);
    FAArray2<double>SB0(iMax + 1, 3);
    FAArray2<double>slicetmp1(iMax + 1, iMax + 1);
    FAArray1<double>slicetmp2(iMax + 1);
    FAArray1<double>TriTa(iMax + 1);
    FAArray1<double>TriTb(iMax + 1);
    FAArray1<double>xnew(iMax + 1);
    FAArray1<double>yi1(iMax + 1);
    /* Initialize step size */
    dx1 = temp18;
    dx2 = temp18;
    FAArray2<double>fpp1(iMax + 1, iMax + 1);
    FAArray1<double>fpp2(iMax + 1);
    FAArray3<double>fpp3(iMax + 1, iMax + 1, kMax + 1);
    FAArray1<double>fpptmp1(iMax + 1);
    Spx = new FAArray1<double>(iMax + 1);
    FAArray1Ref<double> Sp(*Spx);
    FAArray1<double>TriT1i1(iMax + 1);
    FAArray1<double>TriT1j1(iMax + 1);
    FAArray1<double>TriT2i1(iMax + 1);
    FAArray1<double>TriT2j1(iMax + 1);
    FAArray3<double>V(iMax + 1, iMax + 1, kMax + 1);
    FAArray2<double>Vol(iMax + 1, kMax + 1);
    FAArray1<double>zz1(iMax + 1);
    FAArray1<double>zz2(iMax + 1);
    /* Compute the value for nMax0; formula is nMax0 == Max[20, nconv,  
       ndiff]; discretization methods are Implicit[1/2] and             
       CentralSpaceDifference[2]; truncation error is 0; Eq15c. */
    nMax0 = max((double)(max(nconv,20)),(double)(ndiff));
    /* Initialize geometric parameter */
    if (nMax==-999)
        {
        nMax = CRound(sqrt(Accuracy)*nMax0);
        }
    /* Initialize step size */
    dtau = -(TMax / (double)(nMax));
    Sx = new FAArray1<double>(iMax + 1);
    FAArray1Ref<double> S(*Sx);
    /* Initialize coordinate arrays for S, Sp, A */
    CreateGrids1(A,AMax,AMin,dx1,dx2,dy,iMax,kMax,S,Sp,Spot,xMin);
    FAArray1<double>J11(iMax + 1);
    /* Compute the value for J11 on the interior; formula is J11 ==     
       der[S, {x1, 1}]; discretization methods are Explicit; truncation 
       error is Ord[dx1^2]; GCEq1. */
    for (i=0; i<=iMax - 1; i++) {
        J11(i) = (S(i + 1) - S(i)) / dx1;
    }
    SplineForwardSweep(A,0.,TriT1k11,TriT2k11,0,kMax);
    savedt = dtau;
    tau = TMax;
    /* Initialize local loop counter */
    n = 0;
    /* Initialize time-dependent equations */
    temp14 = 1. / ((double)(nsampTot)*(double)(nsampTot));
    for (i=0; i<=iMax; i++) {
        temp12 = temp14*log(S(i) / S0)*log(S(i) / S0);
        for (k1=0; k1<=kMax; k1++) {
            /* Initial value for Vol from IVEq1c. */
            Vol(i,k1) = sqrt(max((A(k1) - temp12) / dTAve,0.));
            /* Initial value for V from IVEqc. */
            for (j=0; j<=iMax; j++) {
                V(i,j,k1) = Vol(i,k1) - K;
            }
        }
    }
    /* Reset discrete indexes. */
    isamp2 = nsampToGo1;
    /* Loop-independent part of: Take a time step. */
    ComputeIndStencils1(D0,dx1,iMax,J11,kMax,r,S,SA0,SB0,sigma);
    while (fabs(tau)>ttest) {
        tend = 0.;
        /* Discrete event initializations. */
        if (isamp2>=isampmin)
            {
            tend = max(tend,RDates1(isamp2));
            }
        while (fabs(tend - tau)>ttest) {
            dtau = max(savedt,tend - tau);
            /* Take a time step. */
            /* Interior discretization methods are CrankNicolson and    
               CentralSpaceDifference[2]. */
            /* Boundary discretization methods are CrankNicolson and    
               OneSidedDifference[1]. */
            /* Total truncation error is bounded by C*(dtau^2 + dx1 +   
               dx1^2). */
            ComputeStencils1(dtau,dtaum1,dx1,iMax,J11,kMax,SA,SA0,SB,SB0
               );
            VectorMatrixMultiply4(SB,V,g,iMax,kMax);
            TriDiag(g,SA,V,iMax,kMax,TriTa,TriTb);
            /* Update time variables  */
            if (tau>=ttest - dtau)
                {
                dtaum1 = dtau;
                }
            /* Update time */
            tau = dtau + tau;
            if (fabs(tau)<max(100*eps,1.e-12)*max(fabs(TMax),0.))
                {
                tau = 0.;
                }
            /* Update local loop counter */
            n++;
        }
        /* End-loop discrete event updates. */
        if ((isamp2>=isampmin&&fabs(RDates1(isamp2) - tend)<ttest))
            {
            /* update for Path[direction[Sp], function[Sp==SumOf[(S -   
               Sp)]], tsample==RDates, nsample==nsampToGo,              
               InterpolateLinear] */
            for (k1=0; k1<=kMax; k1++) {
                for (i=0; i<=iMax; i++) {
                    for (j=0; j<=iMax; j++) {
                        xnew(j) = S(i);
                    }
                    for (j=0; j<=iMax; j++) {
                        slicetmp2(j) = V(i,j,k1);
                    }
                    InterpolateLinearLoop(slicetmp2,Sp,xnew,yi1,0,iMax,0
                       ,iMax,0.,1);
                    for (j=0; j<=iMax; j++) {
                        V(i,j,k1) = yi1(j);
                    }
                }
            }
            /* update for Path[direction[A], (function[A==SumOf[((isamp 
               + nsampSoFar)^-1 ((Log[(S Sp^-1)])^2 - A))]]),           
               tsample==RDates, nsample==nsampToGo, CubicSpline] */
            temp11 = 1. / (double)(isamp2 + nsampSoFar);
            for (j=0; j<=iMax; j++) {
                temp13 = 1. / Sp(j);
                for (i=0; i<=iMax; i++) {
                    SplineCoefficients(V(i,j),A,0.,fpp6,TriT1k11,
                       TriT2k11,0,kMax);
                    temp10 = log(temp13*S(i))*log(temp13*S(i));
                    for (k1=0; k1<=kMax; k1++) {
                        xnew1(k1) = temp11*(temp10 - A(k1)) + A(k1);
                    }
                    CubicSplineLoop(V(i,j),A,fpp6,xnew1,yi2,0,kMax,0,
                       kMax,0.,1);
                    for (k1=0; k1<=kMax; k1++) {
                        V(i,j,k1) = yi2(k1);
                    }
                }
            }
            isamp2--;
            }
    }
    SplineForwardSweep(S,0.,TriT1i1,TriT2i1,0,iMax);
    SplineForwardSweep(Sp,0.,TriT1j1,TriT2j1,0,iMax);
    for (k1=0; k1<=kMax; k1++) {
        for (i=0; i<=iMax; i++) {
            for (j=0; j<=iMax; j++) {
                slicetmp1(i,j) = V(i,j,k1);
            }
        }
        BiCubicSplineCoefficients(slicetmp1,S,Sp,0.,0.,fpp1,TriT1i1,
           TriT2i1,TriT1j1,TriT2j1,0,iMax,0,iMax,1);
        VOut(k1) = BiCubicSpline(slicetmp1,S,Sp,Spot,SpSpot,0,iMax,0,
           iMax,0.,0.,1,1,fpp1,TriT1i1,TriT2i1,TriT1j1,TriT2j1,zz2,fpp2,
           zz1,fpptmp1);
    }
    TriCubicSplineCoefficients(V,S,Sp,A,0.,0.,0.,fpp3,TriT1i1,TriT2i1,
       TriT1j1,TriT2j1,TriT1k11,TriT2k11,0,iMax,0,iMax,0,kMax,1);
    VOut1 = TriCubicSpline(V,S,Sp,A,Spot,SpSpot,ASpot,0,iMax,0,iMax,0,
       kMax,0.,0.,0.,1,1,fpp3,TriT1i1,TriT2i1,TriT1j1,TriT2j1,TriT1k11,
       TriT2k11);
    *iMaxx = iMax;
    *kMaxx = kMax;
    *VOut1x = VOut1;
    return 1;
}

static void ComputeIndStencils1(
    double D0,
    double dx1,
    int iMax,
    const FAArray1Ref<double>& J11,
    int kMax,
    double r,
    const FAArray1Ref<double>& S,
    FAArray2Ref<double>& SA0,
    FAArray2Ref<double>& SB0,
    double sigma
    )
{
    int i;
    double jtemp2,jtemp3,temp1,temp2,temp4,temp5,temp6,temp7,temp8,temp9
       ;
    
    /* *** Key to program variables: *** */
    /* D0: continuous dividend yield */
    /* dx1: step size for x1 */
    /* i: index variable for x1 */
    /* iMax: number of grid cells for x2 */
    /* J11, S: solution variable */
    /* jtemp2, jtemp3, temp1, temp2, temp4, temp5, temp6, temp7, temp8, 
       temp9: common subexpression temporary */
    /* kMax: number of grid cells for y */
    /* r: interest rate */
    /* SA0: part of SA that is proportional to dt. */
    /* SB0: part of SB that is proportional to dt */
    /* sigma: volatility */
    /* Loop-independent part of: Set up and solve system for V. */
    /* assign SA0 */
    temp2 = ((r - D0)*0.25) / dx1;
    temp1 = (sigma*sigma*0.25) / (dx1*dx1);
    for (i=1; i<=iMax - 1; i++) {
        jtemp2 = 2. / (J11(i - 1) + J11(i));
        temp4 = temp1*S(i)*S(i);
        SA0(i,0) = jtemp2*(temp4 / J11(i - 1) - temp2*S(i));
        SA0(i,1) = -(temp4*2.) / (J11(i)*J11(i - 1)) - r*0.5;
        SA0(i,2) = jtemp2*(temp4 / J11(i) + temp2*S(i));
    }
    /* assign SB0 */
    temp9 = ((D0 - r)*0.25) / dx1;
    temp8 = (sigma*sigma*0.5) / (dx1*dx1);
    for (i=1; i<=iMax - 1; i++) {
        jtemp3 = 2. / (J11(i - 1) + J11(i));
        temp7 = jtemp3*0.25;
        temp6 = temp9*S(i);
        temp5 = temp8*S(i)*S(i);
        SB0(i,0) = temp7*(-(temp5*0.5) / J11(i - 1) - temp6)*4.;
        SB0(i,1) = temp5 / (J11(i)*J11(i - 1)) + r*0.5;
        SB0(i,2) = temp7*(-(temp5*2.) / J11(i) + temp6*4.);
    }
    return;
}

static void ComputeStencils1(
    double dtau,
    double dtaum1,
    double dx1,
    int iMax,
    const FAArray1Ref<double>& J11,
    int kMax,
    FAArray2Ref<double>& SA,
    const FAArray2Ref<double>& SA0,
    FAArray2Ref<double>& SB,
    const FAArray2Ref<double>& SB0
    )
{
    int i;
    double eps;
    
    /* *** Key to program variables: *** */
    /* dtau: step size for tau */
    /* dtaum1: value for dtau 1 time steps ago */
    /* dx1: step size for x1 */
    /* eps: machine epsilon */
    /* i: index variable for x1 */
    /* iMax: number of grid cells for x2 */
    /* J11: solution variable */
    /* kMax: number of grid cells for y */
    /* SA: stencil array of the system; the A in Ax=y. */
    /* SA0: part of SA that is proportional to dt. */
    /* SB: coefficients for right hand side of the linear system */
    /* SB0: part of SB that is proportional to dt */
    /* Compute machine epsilon. */
    eps = 1.;
    while (1.!=eps + 1.) {
        eps = eps*0.5;
    }
    eps = eps*2.;
    /* Set up and solve system for V. */
    /* assign SA */
    SA(0,1) = -(1 / (J11(0)*dx1));
    SA(0,2) = 1. / (J11(0)*dx1);
    SA(iMax,0) = -(1 / (J11(iMax - 1)*dx1));
    SA(iMax,1) = 1. / (J11(iMax - 1)*dx1);
    if (!(fpequal(dtau,dtaum1,1000*eps)))
        {
        for (i=1; i<=iMax - 1; i++) {
            SA(i,0) = dtau*SA0(i,0);
            SA(i,1) = dtau*SA0(i,1) + 1.;
            SA(i,2) = dtau*SA0(i,2);
        }
        }
    /* assign SB */
    if (!(fpequal(dtau,dtaum1,1000*eps)))
        {
        for (i=1; i<=iMax - 1; i++) {
            SB(i,0) = dtau*SB0(i,0);
            SB(i,2) = dtau*SB0(i,2);
            SB(i,1) = dtau*SB0(i,1) + 1.;
        }
        }
    return;
}

static void CreateGrids1(
    FAArray1Ref<double>& A,
    double AMax,
    double AMin,
    double dx1,
    double dx2,
    double dy,
    int iMax,
    int kMax,
    FAArray1Ref<double>& S,
    FAArray1Ref<double>& Sp,
    double Spot,
    double xMin
    )
{
    int i,j,k1;
    
    /* *** Key to program variables: *** */
    /* A, AMax, AMin, S, Sp, Spot: solution variable */
    /* dx1: step size for x1 */
    /* dx2: step size for x2 */
    /* dy: step size for y */
    /* i: index variable for x1 */
    /* iMax: number of grid cells for x2 */
    /* j: index variable for x2 */
    /* k1: index variable for y */
    /* kMax: number of grid cells for y */
    /* xMin: minimum physical value in dimension x2 */
    /* Initialize coordinate arrays for S, Sp, A */
    /* Computing S from equation Eqc on interior; formula is S ==       
       E^x1*Spot; discretization methods are Implicit[1/2] and          
       CentralSpaceDifference[2]; truncation error is 0. */
    for (i=0; i<=iMax; i++) {
        S(i) = Spot*exp(dx1*i + xMin);
    }
    /* Computing Sp from equation Eq1c on interior; formula is Sp ==    
       E^x2*Spot; discretization methods are Implicit[1/2] and          
       CentralSpaceDifference[2]; truncation error is 0. */
    for (j=0; j<=iMax; j++) {
        Sp(j) = Spot*exp(dx2*j + xMin);
    }
    /* Computing A from equation Eq2c on interior; formula is A == AMin 
       + AMax*y - AMin*y; discretization methods are Implicit[1/2] and  
       CentralSpaceDifference[2]; truncation error is 0. */
    for (k1=0; k1<=kMax; k1++) {
        A(k1) = AMin + (AMax - AMin)*dy*k1;
    }
    return;
}

static int CRound(
    double delx
    )
{
    
    /* *** Key to program variables: *** */
    /* delx: solution variable */
    if (delx>=0.)
        {
        return (int)(delx + 0.5);
        }
    else
        {
        return -(int)(0.5 - delx);
        }
}

static void SetDateIndices1(
    const FAArray1Ref<double>& RDates,
    FAArray1Ref<double>& RDates1,
    int nsampToGo,
    int *isampminp,
    int *nsampToGo1p,
    double TMax,
    double ttest,
    int arraymin
    )
{
    int i12,isampmin,lower,nsampToGo1,upper;
    
    /* *** Key to program variables: *** */
    /* arraymin: temp arg for number */
    /* i12: local loop variable */
    /* isampmin, isampminp: Minimum of Path array */
    /* lower: lowest significant array value */
    /* nsampToGo: array maximum for RDates */
    /* nsampToGo1, nsampToGo1p: Maximum of Path array */
    /* RDates: solution variable */
    /* RDates1: Auxiliary array for Path sample array */
    /* TMax: minimum physical value in dimension tau */
    /* ttest: minimal size test */
    /* upper: greatest significant array value */
    lower = arraymin;
    upper = arraymin - 1;
    if (arraymin<=nsampToGo)
        {
        while ((lower<=nsampToGo&&-(5*ttest)>RDates(lower))) {
            RDates1(lower) = RDates(lower);
            lower++;
        }
        upper = nsampToGo;
        while ((upper>=arraymin&&TMax + 5*ttest<RDates(upper))) {
            RDates1(upper) = RDates(upper);
            upper--;
        }
        for (i12=lower; i12<=upper; i12++) {
            RDates1(i12) = max(min(TMax - 5*ttest,RDates(i12)),0.);
        }
        }
    isampmin = lower;
    nsampToGo1 = upper;
    *isampminp = isampmin;
    *nsampToGo1p = nsampToGo1;
    return;
}

static void TriDiag(
    const FAArray3Ref<double>& g,
    const FAArray2Ref<double>& SA,
    FAArray3Ref<double>& V,
    int iMax,
    int kMax,
    FAArray1Ref<double>& TriTa,
    FAArray1Ref<double>& TriTb
    )
{
    int i,j,k1;
    
    /* *** Key to program variables: *** */
    /* g: right hand side of the linear system; the y in Ax=y. */
    /* i: index variable for x1 */
    /* iMax: number of grid cells for x2 */
    /* j: index variable for x2 */
    /* k1: index variable for y */
    /* kMax: number of grid cells for y */
    /* SA: stencil array of the system; the A in Ax=y. */
    /* TriTa, TriTb: temporary, same size as diagonal */
    /* V: option value */
    TriTa(0) = 1. / SA(0,1);
    TriTb(0) = -(TriTa(0)*SA(0,2));
    for (i=1; i<=iMax; i++) {
        TriTa(i) = 1. / (TriTb(i - 1)*SA(i,0) + SA(i,1));
        TriTb(i) = -(TriTa(i)*SA(i,2));
    }
    for (k1=0; k1<=kMax; k1++) {
        for (j=0; j<=iMax; j++) {
            V(0,j,k1) = TriTa(0)*g(0,j,k1);
            for (i=1; i<=iMax; i++) {
                V(i,j,k1) = TriTa(i)*(g(i,j,k1) - SA(i,0)*V(i - 1,j,k1
                   ));
            }
            for (i=iMax - 1; i>=0; i--) {
                V(i,j,k1) = V(i,j,k1) + TriTb(i)*V(i + 1,j,k1);
            }
        }
    }
    return;
}

static void ValidateArraySorted1(
    const FAArray1Ref<double>& RDates,
    int nsampToGo
    )
{
    int i1;
    
    /* *** Key to program variables: *** */
    /* i1: index for sample arrays */
    /* nsampToGo: array maximum for RDates */
    /* RDates: solution variable */
    /* see that the sample array is sorted */
    for (i1=1; i1<=nsampToGo - 1; i1++) {
        if (RDates(i1)>=RDates(i1 + 1))
            {
            throw new FAErrorException(		
               "pdeVolSwap1: The sample array for your discrete event is not properly sorted."
               ,UnsortedSampleArray);
            }
    }
    return;
}

static void VectorMatrixMultiply4(
    const FAArray2Ref<double>& SB,
    const FAArray3Ref<double>& V,
    FAArray3Ref<double>& g,
    int iMax,
    int kMax
    )
{
    int i,j,k1;
    
    /* *** Key to program variables: *** */
    /* g: right hand side of the linear system; the y in Ax=y. */
    /* i: index variable for x1 */
    /* iMax: number of grid cells for x2 */
    /* j: index variable for x2 */
    /* k1: index variable for y */
    /* kMax: number of grid cells for y */
    /* SB: coefficients for right hand side of the linear system */
    /* V: option value */
    for (j=0; j<=iMax; j++) {
        for (k1=0; k1<=kMax; k1++) {
            g(0,j,k1) = SB(0,1)*V(0,j,k1) + SB(0,2)*V(1,j,k1);
            g(iMax,j,k1) = SB(iMax,0)*V(iMax - 1,j,k1) + SB(iMax,1)*V(
               iMax,j,k1);
            for (i=1; i<=iMax - 1; i++) {
                g(i,j,k1) = SB(i,0)*V(i - 1,j,k1) + SB(i,1)*V(i,j,k1) + 
                   SB(i,2)*V(i + 1,j,k1);
            }
        }
    }
    return;
}




